/* Auto-generated by genmsg_cpp for file /home/ubuntu/ros/rrt/msg/Path_rrt.msg */
#ifndef RRT_MESSAGE_PATH_RRT_H
#define RRT_MESSAGE_PATH_RRT_H
#include <string>
#include <vector>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/message.h"
#include "ros/time.h"


namespace rrt
{
template <class ContainerAllocator>
struct Path_rrt_ : public ros::Message
{
  typedef Path_rrt_<ContainerAllocator> Type;

  Path_rrt_()
  : path_X()
  , path_Y()
  , path_Z()
  , start_state()
  , hdg(0.0)
  , psi(0.0)
  {
  }

  Path_rrt_(const ContainerAllocator& _alloc)
  : path_X(_alloc)
  , path_Y(_alloc)
  , path_Z(_alloc)
  , start_state(_alloc)
  , hdg(0.0)
  , psi(0.0)
  {
  }

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _path_X_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  path_X;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _path_Y_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  path_Y;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _path_Z_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  path_Z;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _start_state_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  start_state;

  typedef double _hdg_type;
  double hdg;

  typedef double _psi_type;
  double psi;


  ROS_DEPRECATED uint32_t get_path_X_size() const { return (uint32_t)path_X.size(); }
  ROS_DEPRECATED void set_path_X_size(uint32_t size) { path_X.resize((size_t)size); }
  ROS_DEPRECATED void get_path_X_vec(std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) const { vec = this->path_X; }
  ROS_DEPRECATED void set_path_X_vec(const std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) { this->path_X = vec; }
  ROS_DEPRECATED uint32_t get_path_Y_size() const { return (uint32_t)path_Y.size(); }
  ROS_DEPRECATED void set_path_Y_size(uint32_t size) { path_Y.resize((size_t)size); }
  ROS_DEPRECATED void get_path_Y_vec(std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) const { vec = this->path_Y; }
  ROS_DEPRECATED void set_path_Y_vec(const std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) { this->path_Y = vec; }
  ROS_DEPRECATED uint32_t get_path_Z_size() const { return (uint32_t)path_Z.size(); }
  ROS_DEPRECATED void set_path_Z_size(uint32_t size) { path_Z.resize((size_t)size); }
  ROS_DEPRECATED void get_path_Z_vec(std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) const { vec = this->path_Z; }
  ROS_DEPRECATED void set_path_Z_vec(const std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) { this->path_Z = vec; }
  ROS_DEPRECATED uint32_t get_start_state_size() const { return (uint32_t)start_state.size(); }
  ROS_DEPRECATED void set_start_state_size(uint32_t size) { start_state.resize((size_t)size); }
  ROS_DEPRECATED void get_start_state_vec(std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) const { vec = this->start_state; }
  ROS_DEPRECATED void set_start_state_vec(const std::vector<double, typename ContainerAllocator::template rebind<double>::other > & vec) { this->start_state = vec; }
private:
  static const char* __s_getDataType_() { return "rrt/Path_rrt"; }
public:
  ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "f59eb92db85a2cd5997e929beafae112"; }
public:
  ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "float64[] path_X\n\
float64[] path_Y\n\
float64[] path_Z\n\
float64[] start_state\n\
float64 hdg\n\
float64 psi\n\
\n\
"; }
public:
  ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    ros::serialization::serialize(stream, path_X);
    ros::serialization::serialize(stream, path_Y);
    ros::serialization::serialize(stream, path_Z);
    ros::serialization::serialize(stream, start_state);
    ros::serialization::serialize(stream, hdg);
    ros::serialization::serialize(stream, psi);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    ros::serialization::deserialize(stream, path_X);
    ros::serialization::deserialize(stream, path_Y);
    ros::serialization::deserialize(stream, path_Z);
    ros::serialization::deserialize(stream, start_state);
    ros::serialization::deserialize(stream, hdg);
    ros::serialization::deserialize(stream, psi);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    size += ros::serialization::serializationLength(path_X);
    size += ros::serialization::serializationLength(path_Y);
    size += ros::serialization::serializationLength(path_Z);
    size += ros::serialization::serializationLength(start_state);
    size += ros::serialization::serializationLength(hdg);
    size += ros::serialization::serializationLength(psi);
    return size;
  }

  typedef boost::shared_ptr< ::rrt::Path_rrt_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rrt::Path_rrt_<ContainerAllocator>  const> ConstPtr;
}; // struct Path_rrt
typedef  ::rrt::Path_rrt_<std::allocator<void> > Path_rrt;

typedef boost::shared_ptr< ::rrt::Path_rrt> Path_rrtPtr;
typedef boost::shared_ptr< ::rrt::Path_rrt const> Path_rrtConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::rrt::Path_rrt_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::rrt::Path_rrt_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace rrt

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator>
struct MD5Sum< ::rrt::Path_rrt_<ContainerAllocator> > {
  static const char* value() 
  {
    return "f59eb92db85a2cd5997e929beafae112";
  }

  static const char* value(const  ::rrt::Path_rrt_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xf59eb92db85a2cd5ULL;
  static const uint64_t static_value2 = 0x997e929beafae112ULL;
};

template<class ContainerAllocator>
struct DataType< ::rrt::Path_rrt_<ContainerAllocator> > {
  static const char* value() 
  {
    return "rrt/Path_rrt";
  }

  static const char* value(const  ::rrt::Path_rrt_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::rrt::Path_rrt_<ContainerAllocator> > {
  static const char* value() 
  {
    return "float64[] path_X\n\
float64[] path_Y\n\
float64[] path_Z\n\
float64[] start_state\n\
float64 hdg\n\
float64 psi\n\
\n\
";
  }

  static const char* value(const  ::rrt::Path_rrt_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::rrt::Path_rrt_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.path_X);
    stream.next(m.path_Y);
    stream.next(m.path_Z);
    stream.next(m.start_state);
    stream.next(m.hdg);
    stream.next(m.psi);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct Path_rrt_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rrt::Path_rrt_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::rrt::Path_rrt_<ContainerAllocator> & v) 
  {
    s << indent << "path_X[]" << std::endl;
    for (size_t i = 0; i < v.path_X.size(); ++i)
    {
      s << indent << "  path_X[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.path_X[i]);
    }
    s << indent << "path_Y[]" << std::endl;
    for (size_t i = 0; i < v.path_Y.size(); ++i)
    {
      s << indent << "  path_Y[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.path_Y[i]);
    }
    s << indent << "path_Z[]" << std::endl;
    for (size_t i = 0; i < v.path_Z.size(); ++i)
    {
      s << indent << "  path_Z[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.path_Z[i]);
    }
    s << indent << "start_state[]" << std::endl;
    for (size_t i = 0; i < v.start_state.size(); ++i)
    {
      s << indent << "  start_state[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.start_state[i]);
    }
    s << indent << "hdg: ";
    Printer<double>::stream(s, indent + "  ", v.hdg);
    s << indent << "psi: ";
    Printer<double>::stream(s, indent + "  ", v.psi);
  }
};


} // namespace message_operations
} // namespace ros

#endif // RRT_MESSAGE_PATH_RRT_H

